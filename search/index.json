[{"content":"概念 对于一些关于进程、线程、协程以及并发与并行的概念，在这里就不具体提了(其实我也不太搞得清楚)。\n可以参考\u0026ldquo;Go入门指南\u0026quot;的第十四章\nGoroutine goroutine是由Go运行管理的轻量级线程(协程)，Go可以调用多个goroutine来充分调用系统资源，来实现高速的运算。\n认识Goroutine 通过一个简单的例子来认识如何使用goroutine。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package main import ( \u0026#34;fmt\u0026#34; ) func hello(){ fmt.Println(\u0026#34;Hello\u0026#34;) } func main() { go hello()\t//使用goroutine来调用hello函数 fmt.Println(\u0026#34;1\u0026#34;) } 一个最简单的goroutine就实现了，但是当你运行这段代码时会发现问题，输出的结果为1，并没有输出go hello()语句。\n这是因为与其他函数不同，go在goroutine执行结束前会直接跳到下一行运行，可能导致主函数(主函数也可以理解为主goroutine，而其他goroutine为子goroutine)已经结束，程序已经终止了，自然不会返回goroutine的语句。\n通过time.Sleep()函数可以简单的解决(但并不优雅)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func hello(){ fmt.Println(\u0026#34;Hello\u0026#34;) } func main() { go hello()\t//使用goroutine来调用hello函数 fmt.Println(\u0026#34;1\u0026#34;) time.Sleep(1 * time.Second) //使程序在结束之前先睡眠1s } 通过加上time.Sleep(1 * time.Second)语句会让程序在结束之前先行等待，从而让子goroutine返回。\nWaitGroup 虽然time.Sleep()可以解决上面的问题，但你可能意识到了：我怎么知道goroutine在多久后结束？而通过sync包中的sync.WaitGroup便可以实现goroutine的同步。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) var wg sync.WaitGroup //WaitGroup就相当于一个计数器，默认值为0 func hello(i int) { defer wg.Done() // 在每个goroutine执行完成后使计数器-1 fmt.Printf(\u0026#34;Hello %d\\n\u0026#34;, i) } func main() { for i := 0; i \u0026lt; 10; i++ {\twg.Add(1) //使计数器+1 go hello(i) } wg.Wait() //使程序阻塞，直到计数器为0(也就是所有子goroutine完成) } 信道(通道) Channel Go提倡通过通信来实现共享内存，而不是通过共享内存来实现通信\n而根据这一原则，我们在使用goroutine时尽量不要使用全局变量，会产生大量问题，而为了在不同的goroutine之间实现共享内存，通过信道便可以实现通信。\n创建信道 1 2 var 信道实例 chan 信道传输的数据类型 var chan1 chan int 通过var 语句可以声明一个信道，但是其初始值为nil,需要用make函数将其初始化\n1 chan1 = make(chan int) 当然，也可以将声明与初始化合并这样写：\n1 chan1 := make(chan int) 数据传输 对于信道我们可以传入数据，也可以读取数据。\n1 2 chan1 \u0026lt;- 100 // 向chan1信道中传入100 a := \u0026lt;- chan1 //从chan1信道中读取数据，得到100 关闭信道 通过close()函数可以将信道关闭。在关闭之后，依然可以从信道中读取数据，但是接受到的值永远会是0。\n1 2 chan1 := make(chan int) close(chan1) 对于信道是否关闭，go提供了多返回值来判断：\n1 2 3 chan1 := make(chan int) close(chan1) a,ok := \u0026lt;-chal\t//ok的值为false,表示信道已关闭，若为true则为开 缓冲 在创建信道时，我们还可以设定信道的容量\n1 2 chan1 := make(chan int) //不填信道的容量默认为0 chan2 := make(chan int,10) //设定信道的容量为10 通过cap()函数可以得出信道的容量，而len()函数返回信道中当前的数据个数。\n我们将容量为0的信道称为无缓冲信道，而将容量大于0的信道称为有缓冲信道。\n无缓冲信道 对于无缓冲信道，发送数据与接受数据是同时进行的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import \u0026#34;fmt\u0026#34; func sum(s []int, c chan int) { sum := 0 for _, v := range s { sum += v } c \u0026lt;- sum // 将和送入 c } func main() { s := []int{7, 2, 8, -9, 4, 0} c := make(chan int) go sum(s[:len(s)/2], c)\t// -5 go sum(s[len(s)/2:], c)\t// 17 x, y := \u0026lt;-c, \u0026lt;-c // 从 c 中接收，接收的顺序与传入的顺序相同,传入的协程同步进行，并不知道哪个先完成，比较随机 fmt.Println(x, y) } 有缓冲信道 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package main import \u0026#34;fmt\u0026#34; func sum(s []int, c chan int) { sum := 0 for _, v := range s { sum += v } c \u0026lt;- sum // 将和送入 c } func main() { s := []int{7, 2, 8, -9, 4, 0} c := make(chan int) go sum(s[:len(s)/2], c)\t// -5 go sum(s[len(s)/2:], c)\t// 17 x, y := \u0026lt;-c, \u0026lt;-c // 从 c 中接收，接收的顺序与传入的顺序相同 fmt.Println(x, y, x+y) // -5 17 12 } ","date":"2023-03-05T09:36:12Z","permalink":"http://blog.nothingalr8.top/post/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84go-%E5%B9%B6%E5%8F%91/","title":"从零开始的Go(?)-并发"},{"content":"","date":"2023-01-02T15:35:23Z","permalink":"http://blog.nothingalr8.top/post/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84go12-%E6%96%B9%E6%B3%95/","title":"从零开始的Go(12)-方法"},{"content":"函数规则 除main函数与init函数之外，所有函数都可以有参数与返回值。\n当函数执行到代码的最后一行( } 之前)或return语句时退出，return后面可以带有任意个参数，作为函数的返回值。\n要注意的是 {需要和函数的名字写在同一行，如：\n1 2 3 4 5 6 7 8 //错误的定义： func g() { } //正确的定义： func g(){ } 若函数要被在其他包中调用，要首字母大写。\n函数的分类 在Go语言中共有3种函数类型：\n对于Go语言中函数类型的分类，各有各的不同，而我将go中的函数分为以下4种：\n特殊函数 普通函数 匿名函数 方法(下一节再讲) 特殊函数 go中共有两种较为特殊的函数，为main函数和init函数。\nmain函数 像其他语言一样，go语言也有main函数，也是从main函数开始运行程序。\n在整个程序中，应该有且仅有一个main函数，出现多个会导致程序运行出错。\n在go中，main函数所在的位置不太重要，但是鉴于可读性的需求，最好把main函数放在程序的最前面，或是单独写成一个源文件。\ninit函数 除main函数之外，go中另一种非常特殊的函数为init函数。\ninit函数不能够被调用，而是会在每个包完成初始化后自动执行，并且它的执行优先级高于main函数。\n每个源文件最多只能有一个init函数，在多个包中的init函数会按照包的依赖关系依次执行。\n普通函数 定义方法：\n1 2 3 4 func name(arg1 type1, arg2 type2, ..., argn typen) (functype1, functype2, ..., functypen){ //do something return res1, res2, ..., resn } name为函数名\nfunctype为函数返回值的类型，可以省略，若有则函数必须要有返回值，与返回值数量对应\narg为函数的参数，可以是多个，也可以没有\ntype为接受参数的类型，可以省略\nres为函数返回值，可以是多个，也可以没有\n匿名函数 当我们不希望给函数起名字时，可以使用匿名函数，这样的函数不能独立存在，但是可以赋值给变量，然后通过变量名对函数进行调用，当然也可以直接调用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /* func() { fmt.Println(\u0026#34;Hello!\u0026#34;) } 不能独立存在，但可以像下面这么使用 */ a := func() { fmt.Println(\u0026#34;Hello!\u0026#34;) }\t//a成了一个闭包，后面会讲 a() func() { fmt.Println(\u0026#34;Hello!\u0026#34;) }()\t//在函数最后加上()可以直接调用 defer和追踪 ","date":"2022-10-31T17:35:23Z","permalink":"http://blog.nothingalr8.top/post/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84go11-%E5%87%BD%E6%95%B0/","title":"从零开始的Go(11)-函数"},{"content":"不知不觉，我已经大一了，我也已经玩了十多年的游戏了。而悄无声息中，游戏也成为了我生活的一部分，无法分隔。回想我与游戏的故事，我有太多可以说的了。我的游戏史，在无形之中记录了我人生的轨迹。我想通过这篇博文，来讲述一下我与游戏的故事，并穿插一些我对游戏与生活的看法。\n初识游戏 身为一个零零后，我的游戏启蒙并不是游戏机，而是家用电脑。\n说实话，我已经记不清我家里是什么时候有电脑的了，好像打我记事起，便有了。我只记得，在当时，在我和小伙伴中，只有我家有一台电脑，一台安装了Windows XP系统的电脑。在几年前，我闲来无事，便把电脑拆了，发现这竟然是一台联想的品牌机，用的一颗奔腾处理器(具体是什么，我已经记不清了)，还有独显，以及在现在家用电脑上一般都见不到的独立声卡(现在的大多数都集成在主板上了，非专业的不需要独立声卡)。\n应该和许多人一样，4399、7k7k等小游戏网站，是童年中不可磨灭的记忆。在当时，4399中的各种游戏成了我与小伙伴们周末的伴侣，一到周末，我家就成了聚集地，我们开始玩各种多人合作小游戏，像是拳皇(当时大家都不会玩，都是一通乱按)，像是造梦西游等等。那时的日子，真是充满快乐，至今想起仍记忆犹新。而后来，渐渐的，小伙伴们家中也渐渐有了电脑，我们也因为学业问题，聚得越来越少。现在，我们各奔东西，想要在聚在一起已经不再现实了。\n统治我童年的，不仅有flash小游戏，还有各种网游。当时，在小伙伴的建议下，我接触了CF，LOL等腾讯网游。我还依稀记得当时看到游戏界面的“未满18周岁禁止游玩”字样时的样子，我在电脑前犹豫了几分钟后，才进入游戏，并用网上找的身份证号来通过验证。现在看来，当时的实名认证监管是真的松，而现在的小学生日子可真不好过。\n我在童年时期，就见到了网游的圈钱能力。CF一把英雄级武器卖4位数，买的人还不少。当时上小学的我就看到我的一个小伙伴的同学，在CF里冲了好几万(听说人家小学一个月零花钱就有好几千)，光是一样的英雄级武器就有好几把。我也算是第一次见识了有钱人，感受到了世界的贫富差异与社会的不公平。\n虽说，网游对我充满吸引力，但我玩的还算比较少，没有太多的感情。\n在这一阶段，我也刚刚接触到了单机游戏，但当时，我对这类游戏的概念都搞不清。我尝试着自己从盗版网站上下了刺客信条1来玩，但是，不知道为什么，我的游戏没有汉化，我也不会搞，就没有玩下去了。当多年以后，我重新接触到刺客信条系列游戏时，已经是奥德赛了，但是，奥德赛却只能给我短暂的几十小时的快乐游戏时光了，当然，这都是后话了。\n而在我小学四五年级时，我接触了对我人生具有非凡意义的一款游戏——Minecraft。\n我与Minecraft 我的初中三年，算是我接触游戏种类比较少的时期，我的大多数时间都是与minecraft度过的。\n我与minecraft相识是在小学，当时我没有正版概念，从网络上寻找各种版本与整合包来玩，在当时，我只是稀里糊涂地玩，直到开始接触各种自媒体。\n好像是在初中那会，我开始将大量的时间放在看自媒体视频上，主要都是与minecraft相关的，包括游戏实况，游戏教学，模组介绍等。也是通过自媒体，我开始真正了解这款游戏。\n我开始接触模组(Mod)、资源包(材质包)、光影，了解整合包的概念，也开始接触到社区(虽然是游戏社区)。我觉得这一阶段，我学习到了特别特别多的东西，不单单是如何安装模组、材质包、光影、如何做一个简单的整合包，还有通过社区、通过网络寻找教程去解决问题的方法，这对我现在的自主学习帮助非常大。\n而也是通过minecraft，我开始了解了什么是正版游戏。我也迫切地希望成为一个正版游戏玩家，但碍于当时我没有网络支付手段，我并没有买正版minecraft。到我买minecraft正版，已经是高二了，minecraft玩的已经比较少了。\n爆发期 在初二，我家里就已经在安排着搬家的事，到了初三，才搬了进去(旧电脑没有搬)，我也有了一个全新的房间。我希望我的房间里有一台电脑，但是当时初三的中考，我发挥失常，没有得到理想的成绩，没好意思。\n在这期间，我一直想着买电脑这件事，因此开始关注一些装机博主。讲真的，这段经历让我收获了很多。我开始了解了一台电脑的组成配件，也明白了怎么装电脑（后来我也确实是自己装起来的），我在心中为自己写了一份配件清单，想着攒钱买电脑。\n直到高一上学期结束，我拿到了奖学金，加上之前攒的钱与父母的补贴，才算真正实现了我这一小目标。当时我希望从网上买配件自己组装，但我的父母并不信任我，认为我只是从同学那道听途说，强拉着我去电脑城买。但好歹我是懂一点东西的，并没有被宰，但现在想想依然被小坑了一把。当时已经出了20系显卡，我因为资金原因还是选择了10系，我希望买新出的1660 super，商家硬说没货了，把库存的1660塞给了我。最后，在商家的店里，我顶着父亲的反对，是自己装的电脑。\n而紧接着来的便是疫情与网课。当时，我和我的父母都很幸庆，觉得电脑买的真及时。我父母觉得我有了电脑，就不用盯着小小的手机屏幕上网课，保护了我的眼睛；而我则觉得，网课期间真是一段用来打游戏的好时间，有了双设备(手机+电脑)真是如虎添翼。\n现在想想，疫情期间我真的玩了好多种类的游戏。我开始接触宫崎英高，从通关只狼到尝试魂2(当时没有通关，被劝退了，魂2太难了，我觉得是魂系列最难的)。我开始玩一些独立游戏，从一边听网课一边玩正版PVZ，到熬夜玩杀戮尖塔。\n后来，我便是真正喜欢上了单机游戏，也开始接受花钱买正版游戏，也开始对情怀付费。我已经记不清玩了多少游戏了，就提几个因为某种原因印象较深的游戏吧。\n第一个是老滚5(上古卷轴5)，这是我这阶段玩的为数不多的盗版游戏了(有些游戏国内并没有正规购买渠道，懂得都懂)。并不是因为我买不起正版，不想买正版。是我已经买了正版了，但是正版体验并没有盗版好，这是一件挺离谱的事。盗版可以直接下别人调试好的整合包，直接变身少女卷轴。而正版加模组有一堆问题，不是轻易可以解决的。这款游戏当时对我来说是挺震撼的(指打了模组的)，其实B社这家公司对我来说也是挺震撼的，~~可以有那么多bug，还需要用玩家制作的模组来修bug。~~但老滚这种游戏非常对我的胃口，老滚6或许是我现在最期待的游戏了。我并没有对它报太高的希望，只希望想打了模组的老滚5一样(老滚5装了太多模组会有各种问题)，但没有太多影响体验的bug就行。\n赛博朋克2077算是另一款我印象非常深的游戏，也是第一款我全款预购的游戏。2077的宣传与营销策略做的是在是太好了，加上之前巫师3的良好体验，我对CDPR的好感也比较高，我就上钩了。宣传的游戏与实际体验的游戏完全不是一个东西，而且游戏的优化实在是太烂了。尽管更新了许多补丁，不断优化，2077在今天仍然是一款超前的游戏(指对配置的要求)。哪怕是恐怖的4090，不借助DLSS，也无法在4k全高画质下把这游戏跑到100帧以上。而通过这次的经历，我也得到了一个教训——不要乱预购游戏，等出来之后看评价再买。后来，我全款预购的游戏也就只有仁王2与艾尔达法环了，前者是因为看过了大量的实况(仁王2是PS5移植到PC的)，后者是因为宫崎英高。\n还有就是传说之下，一款挺惊艳的独立游戏。从这款游戏开始，我明白了一个人也可以做出让世人震惊的游戏，心中埋下了一颗做独立游戏的种子(现在或许已经被深深掩埋了起来吧)。也是从这款游戏开始我开始喜欢独立游戏，也相信TGA，开始玩一下拿了TGA的游戏。但是2020年这一年，算是告诉我了所有奖项都tm的是一坨狗屎。\n在这阶段，我还是开始关注游戏设计了(毕竟想做游戏)，也阅读了2本关于游戏的专业书籍，有些不止于游戏的收获吧。\n现阶段 现在说实话，比起过去，我已经算是玩游戏玩的比较少了。一是没有什么时间，大学并没有想象的那么轻松，我还需要学习很多东西，目标与自身存在着不小的差距。还有就是我已经玩不太动游戏了。\n我是真的玩不动什么游戏了，似乎是得了“电子阳痿”？我还记得我以前“沉迷游戏”的样子，玩上一款小小的游戏可以让我开心半天，是我内心对游戏的标准提高了吗？我想，是节奏变快了，我无法静下心来真真欣赏体验游戏了。\n但是我对游戏的兴趣没有削减，依然渴望去接触新的游戏。我希望通过写博客的方式，将我对游戏的体验以及感悟记录下来，希望我能一直对游戏充满热情，重新找回游戏的状态。\n再者，我就是希望自己买一台Switch，开始我对任天堂独占游戏的体验。\n","date":"2022-10-30T20:06:25Z","permalink":"http://blog.nothingalr8.top/post/%E6%88%91%E4%B8%8E%E6%B8%B8%E6%88%8F/","title":"我与游戏"},{"content":"结构体 定义格式：\n1 2 3 4 5 type identifier struct { field1 type1 field2 type2 ... } 示例：\n1 2 3 4 type s struct { a int b int } 这将定义一个名叫s的结构体，结构体包含了2个int字段，分别为a和b。\n使用以下命令来声明一个s结构体z，并使用结构体x的字段：\n1 2 3 var x s x.a = 50 x.b = 100 也可以通过new()来创建一个结构体指针：\n1 2 3 4 x := new(s)\t//创建一个结构体指针 //等同于： //var x *s //x = new(s) 可以通过以下代码看出两者的区别：\n1 2 3 4 5 6 7 8 type s struct { a int b int } x1 := new(s) x2 := s fmt.Println(x1)\tfmt.Println(x2) 值得注意的是，也可以直接使用以下命令对引用结构体指针的字段(同结构体)：\n1 2 3 x1 := new(s) x1.a = 50 (*x1).b = 100\t//这么做也是可以的 使用工厂方法创建结构体 Go中常常使用工厂方法来创建结构体：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 type File struct { fd int // 文件描述符 name string // 文件名 } func NewFile(fd int, name string) *File { if fd \u0026lt; 0 { return nil } return \u0026amp;File{fd, name} } f := NewFile(10, \u0026#34;./test.txt\u0026#34;) 带标签的结构体 在结构体后可以添加标签：\n1 2 3 4 type File struct { fd int \u0026#34;1\u0026#34; name string \u0026#34;2\u0026#34; } 使用反射reflect来使用标签，这将在反射中提到。\n匿名字段 结构体可以使用匿名字段，如：\n1 2 3 4 type File struct { a int int } 但是，同一个类型的匿名字段最多只有一个，使用以下代码来使用这一字段：\n1 2 3 s := new(File) s.a = 10 s.int = 20 内嵌结构体 在结构体中也可以含有一个结构体，如：\n1 2 3 4 5 6 7 8 9 type s1 struct { a\tint b\tint } type s2 struct { c\tint s1 } 在名字无冲突的情况下，可以使用这样调用：\n1 2 3 4 s := new(s2) s.c = 10 s.a = 20 s.s1.b = 30 //当名字有冲突时只能这样，无冲突时与s.b结果一样 ","date":"2022-10-29T17:35:23Z","permalink":"http://blog.nothingalr8.top/post/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84go10-%E7%BB%93%E6%9E%84%E4%BD%93/","title":"从零开始的Go(10)-结构体"},{"content":"定义 可以使用map()来声明一个map。\n1 var identifier map[keytype]valuetype\t//只是声明了一个map，但是没有分配内存，不能用来存放键值。 一个map是无序的键值对的集合，类似与python中的dictionary，可以动态增加，未初始化的map值为nil。\n在map中，key可以为float、int、string等类型，但不能为切片与结构体(含有数组切片的结构体不能作为 key，只包含内建类型的 struct 是可以作为 key 的)，可以为指针与接口。\n而value可以为任意类型(但是使用空接口时，需要先做一次类型断言)。\n使用len()可以获取map中键值对的数量。\n初始化 在go中，map是引用类型，未初始化的值为nil，使用以下方式来初始化map：\n1 2 3 4 5 var map1 map[string]string map1 = make(map[string]string) var map2 map[string]string map2 = map[string]string{\u0026#34;key1\u0026#34;:\u0026#34;1\u0026#34;, \u0026#34;key2\u0026#34;:\u0026#34;2\u0026#34;} 也可以将声明与初始化写在一起：\n1 2 map1 := make(map[string]string)\t//声明+分配内存 map2 := map[string]string{\u0026#34;key1\u0026#34;:\u0026#34;1\u0026#34;, \u0026#34;key2\u0026#34;:\u0026#34;2\u0026#34;}\t//声明+初始化 使用 添加元素 格式：\n1 identifier [newkey] = value\t//需要先初始化 删除元素 使用delete()函数来删除map中的元素：\n1 delete(identifier, \u0026#34;key\u0026#34;) 获取key对应的value 格式：\n1 2 a,b = identifier[key]\t//将map identifier的key值对应的value赋给变量a // b将返回一个布尔值，若key存在则为true，反之则为false，若不需要判断，可以省略 for-range的使用 格式：\n1 2 3 for key, value := range map1 { fmt.Printf(\u0026#34;key is: %d\\n\u0026#34;, key) } 第一个返回值key为map的键值，第二个返回值value为键值对应的值。但是，map是一个无序集合，所以返回的key的顺序并无法确定。\n","date":"2022-10-28T21:35:23Z","permalink":"http://blog.nothingalr8.top/post/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84go9-map/","title":"从零开始的Go(9)-Map"},{"content":"在程序运行时，使用到的变量值被存储在内存中，而每个内存块都有一个地址，当程序使用变量时，实际上就是在内存中使用一个地址中的值。\n在Go中，取地址符为\u0026amp;，可以用与获取一个变量的地址。\n示例：\n1 2 3 var i = 1 fmt.Printf(\u0026#34;%d\u0026#34;,i)\t//输出i的值 fmt.Printf(\u0026#34;%p\u0026#34;,\u0026amp;i)\t//输出i的内存地址 指针变量 指针是指向了一个值的内存地址的变量。\n声明格式：\n1 var identifier *type identifier：定义的指针的名称\ntype：指针类型，即指向的值的类型\n当一个指针被定义但没有分配到变量时，其默认值为nil。\n示例：\n1 2 3 4 var ptr *int i := 1 ptr = \u0026amp;i\t//为指针赋值 fmt.Printf(\u0026#34;%p\\n\u0026#34;,ptr) *可以作为类型转换器，用于获取指针指向内容的值(不同于类型定义中的*)\n示例：\n1 2 3 4 var ptr *int i := 1 ptr = \u0026amp;i fmt.Println(*ptr)\t//结果为1 指针的使用 示例：\n1 2 3 4 5 6 var ptr *int i := 1 ptr = \u0026amp;i *ptr = 2 fmt.Println(*ptr)\t//结果为2 fmt.Println(i)\t//结果为2 通过示例可以发现，通过对*ptr的赋值，也同时改变了变量i的值。\n注意，Go中不能对指针进行运算。\n","date":"2022-10-28T17:35:23Z","permalink":"http://blog.nothingalr8.top/post/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84go8-%E6%8C%87%E9%92%88/","title":"从零开始的Go(8)-指针"},{"content":"数组 数组是具有相同唯一类型的一组以编号且长度固定的数据项序列，是一种基本类型。\n定义 定义格式：\n1 var identifier [len]type indentifier：数组名\ntype：数组类型，可以为整形、浮点型、字符型、字符串等\nlen：数组的长度。\n也所以可以通过 new() 来创建：\n1 2 var identifier = new([len]type) identifier := new([len]type) 数组第一个元素的索引为0，最后一个元素的索引为len-1。\nGo 语言中的数组是一种值类型（不像 C/C++ 中是指向首元素的指针)。\n赋值 通过以下几种方法对数组进行赋值：\n1 2 3 4 arr1[i] = value\t//对数组的单个元素赋值 var arr2 = [5]int{18, 20, 15, 22, 16} //在定义时同时赋值 var arr3 = [5]int{18, 20}\t//a[0]=18,a[1]=20,后面被赋值为0 var arrKeyValue = [5]string{3: \u0026#34;Chris\u0026#34;, 4: \u0026#34;Ron\u0026#34;}\t//赋值了a[3]与a[4] 切片 定义 切片(slice)是对数组一个连续片段的引用，但和数组不同，切片的长度可以在运行过程中被修改，是引用类型。\n定义格式：\n1 var identifier []type\t//[]中不需要加长度 在默认状况下，未进行初始化与赋值的切片长度为0，默认为nil。\n也可以通过make()来创建切片：\n1 2 identifier := make([]type, len, capacity)\t//其中capacity部分可省略 var identifier make([]type, len) 其中，len为切片初始长度，capacity为切片容量。\n初始化与赋值 ​\n长度与容量 for-range的使用 ","date":"2022-10-24T17:35:23Z","permalink":"http://blog.nothingalr8.top/post/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84go7-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/","title":"从零开始的Go(7)-数组与切片"},{"content":"分支结构 if-else结构 if 是用于测试某个条件（布尔型或逻辑型）的语句，如果该条件成立，则会执行 if 后由大括号括起来的代码块，否则就忽略该代码块继续执行后续的代码。如果忽略了，若存在else分支，则执行else后由大括号括起来的代码块。\n注意：与C语言不同，即使if之后只有一条需要执行的代码，也需要用大括号括起来。同时，if的右大括号需要与else在同一行。\n1 2 3 if condition { // do something } 1 2 3 4 5 if condition { // do something } else { // do something } 当然也可以在else后面添加if，来进行多分支判断。其中，else-if分支没有数量限制。\n1 2 3 4 5 6 7 if condition1 { // do something } else if condition2 { // do something else } else { // catch-all or default } 同时，if语句也可对数值进行初始化\n1 2 3 if initialization; condition { // do something } 如：\n1 2 3 if val := 10; val \u0026gt; max { // do something } 值得注意的是，如果if结构内有 break、continue、goto 或者 return 语句时，一般省略 else 部分。\n如，无论满足哪个条件都会返回 x 或者 y 时，一般使用以下写法：\n1 2 3 4 if condition { return x } return y 同时在 if-else 结构的两个分支里都使用 return 语句，这将导致编译报错。\nswitch结构 Go中switch是一个非常灵活的结构，它可以接受任何形式的表达式。\n每一个case都是唯一的，从上到下逐一测试，直到匹配的case或是default，然后执行语句，case后面也不需要加大括号。\n注意：go的switch在执行完case的语句后会直接退出，不需要额外加break。如果在执行完每个分支的代码后，还希望继续执行后续分支的代码，可以使用fallthrough关键字来达到目的。\nswitch后面可以跟着一个变量：\n1 2 3 4 5 6 7 8 switch var1 { case val1: // do something case val2: // do something default: // do something } 也可以这样使用：\n1 2 3 4 5 6 7 8 switch { case condition1: // do something case condition2: // do something default: // do something } 这种使用方式非常像多重if-else结构，但看上去更简洁，可读性更高。\nswitch语句也可以加上初始化语句(参考if-else的初始化)：\n1 2 3 4 5 6 7 8 switch initialization { case condition1: // do something case condition2: // do something default: // do something } 循环结构 for语句 在go中，没有while，只有for循环，但是for可以替代while使用。\n基于计数器的迭代 1 2 3 for initialization; codition; post { // do something } initialization：初始化赋值语句，只执行一次\ncondition：循环控制条件，每次循环开始先判断\npost：控制循环变量，每次循环结束执行一次\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 for i := 0; i \u0026lt; 5; i++ { fmt.Printf(\u0026#34;This is the %d iteration\\n\u0026#34;, i) } /* 输出结果 This is the 0 iteration This is the 1 iteration This is the 2 iteration This is the 3 iteration This is the 4 iteration */ 基于条件判断的迭代 这种循环类似其他语言中的while循环。\n1 2 3 for conditon { // do something } 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 i := 0 for i \u0026lt;= 5{ fmt.Printf(\u0026#34;%d\u0026#34;,i) i++ } /* 输出结果 0 1 2 3 4 5 */ for-range结构 在go中，可以使用for-range结构来迭代任意一个集合(包括数组和map)，一般的结构为：\n1 2 3 for index, val := range coll { } 使用这种结构可以得到每次迭代对应的索引index和值val。\n同时，字符串也可以进行迭代，来获取每个字节的索引(位置)与值。\nbreak和continue break可以被用于任何一种for语句中，用于退出循环，但是只会退出一层循环。\ncontinue只能被用于循环中，用于结束这一次循环，接着进行循环条件判断，进入下一次循环。\n标签与goto for、switch 或 select 语句都可以配合标签（label）形式的标识符使用，即某一行第一个以冒号结尾的单词。\n（标签的名称是大小写敏感的，为了提升可读性，一般建议使用全部大写字母）\n1 2 3 4 5 a := 1 goto LABEL1 LABEL1: a = 10 fmt.Println(a) 注意：标签与goto的使用非常有可能会导致意大利面条式代码，这会使代码变得非常糟糕，尽量减少使用或不使用。\n","date":"2022-10-22T17:35:23Z","permalink":"http://blog.nothingalr8.top/post/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84go6-%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/","title":"从零开始的Go(6)-控制结构"},{"content":"字符串 在Go中，字符串是 UTF-8 字符的一个序列，一个字符可能占用1个字节(ASCII码)，或是2~4个字节。\n定义 通过以下两种形式定义字符串：\n1 2 var s1 string s2 := \u0026#34;Hello!\u0026#34; 索引与切片 索引 可以将一个字符串看成数组，来获取其某一字节上的值。类似数组，string[0]对应第一个字节。\n1 2 3 4 s1 := \u0026#34;hello\u0026#34; fmt.Println(s1[0])\t//结果为104，对于h的ASCII码 fmt.Println(s1[3])\t//结果为108，对于l的ASCII码 fmt.Println(string(s1[3]))\t//加上string()函数,则输出字符 而对于中文等多字节字符，并不可以直接使用索引来得出各位字符，只能得到某个字节的值，需要先转换为rune切片：\n1 2 3 s2 := \u0026#34;你好！\u0026#34; fmt.Println(([]rune(s2))[0])\t//结果为20320，为4f60的十进制表示形式，为\u0026#39;你\u0026#39;的UTF-8编码 fmt.Println(string(([]rune(s2))[0]))\t//结果为\u0026#34;你\u0026#34; 切片 通过以下方式来获取字符串的某几个连续字节上的值：\n1 2 3 4 5 s1 := \u0026#34;hello!\u0026#34; fmt.Println(s1[0:5])\t// \u0026#34;hello\u0026#34;\t遵循向前取整的规则，取到索引为4的字节 fmt.Println(s1[:5])\t// \u0026#34;hello\u0026#34;\t前一个数为空，即从0开始 fmt.Println(s1[4:])\t// \u0026#34;o!\u0026#34;\t后一个数为空，即到最后一个字符为止 fmt.Println(s1[:]) // \u0026#34;hello!\u0026#34;\t若两个字符都为空，则取整个字符串 同样的，对与中文字符，需要先转化为rune切片：\n1 2 3 s2 := \u0026#34;你好！\u0026#34; fmt.Println(([]rune(s2))[0:2])\t//结果为[20320 22909]，为\u0026#39;你\u0026#39;与\u0026#39;好\u0026#39;的UTF-8编码 fmt.Println(string(([]rune(s2))[0:2]))\t//加上string()函数，则输出\u0026#34;你好\u0026#34; 编辑 在Go中，无法直接对string的某一位上的值进行改变，需要先进行类型的转化。\n运行以下命令会出错：\n1 2 s1 := \u0026#34;hello!\u0026#34; s1[0] = \u0026#39;1\u0026#39; 如果是单一的ASCII码组成的字符串，则可以转化成[]byte类型，而含有多字节字符的则需转化位[]rune类型。\n1 2 3 4 5 6 7 8 9 s1 := \u0026#34;hello!\u0026#34; s1_ := []byte(s1)\t//转化成[]byte类型 s1_[0] = \u0026#39;H\u0026#39; fmt.Println(string(s1_))\t//结果为\u0026#34;Hello!\u0026#34; s2 := \u0026#34;你好！\u0026#34; s2_ := []rune(s2)\t//转化成[]rune类型 s2_[0] = \u0026#34;您\u0026#34; fmt.Println(string(s2_))\t//结果为\u0026#34;您好！\u0026#34; 拼接与比较 拼接 使用+对字符串进行拼接（当然可以使用+=），如：\n1 2 3 s1 := \u0026#34;Hello \u0026#34; s2 := \u0026#34;World!\u0026#34; s3 := s1+s2\t//s3结果为\u0026#34;Hello World!\u0026#34; 比较 字符串的比较是按字节比较，从第一个字节开始比较，大的为字符串的第一个字节大的字符串，如果第一个字节一样大，则顺次比较。\n1 2 3 s1 := \u0026#34;ab\u0026#34; s2 := \u0026#34;123\u0026#34; fmt.Println(s1 \u0026gt; s2) //结果为true 求长度 可以通过len()函数来获取字符串的长度，但是这个函数实际上求的是字符串的字节长度。\n可以通过以下代码来看出：\n1 2 3 4 5 s1 := \u0026#34;Hello!\u0026#34; fmt.Println(len(s1))\t//得出的结果为6，一个ASCII字符占1个字节 s2 := \u0026#34;你好！\u0026#34; fmt.Println(len(s2))\t//得出的结果为9，在UTF-8中，每一个中文及全角字符占3个字节 那要如何计算出除ASCII码之外字符的实际长度呢？也需转化为rune切片：\n1 2 s2 := \u0026#34;你好！\u0026#34; fmt.Println(len([]rune(s2)))\t//得出结果为3 相关包 strings包 strings包为go提供了一系列对字符串进行操作的函数。\n前缀与后缀 1 2 strings.HasPrefix(s, prefix string) bool\t//判断前缀，若对与字符串s来说，前缀为prefix，则返回true，反之则返回false strings.HasSuffix(s, suffix string) bool\t//判断后缀，同判断前缀 示例：\n1 2 s1 := \u0026#34;hello\u0026#34; fmt.Println(strings.HasPrefix(s1,\u0026#34;h\u0026#34;))\t//结果为true 包含 strings.Contains(s, substr string) bool\n判断字符串s是否包含substr部分，若包含，返回true，反之则返回false\n示例：\n1 2 3 s1 := \u0026#34;hello\u0026#34; fmt.Println(strings.Contains(s1,\u0026#34;hell\u0026#34;))\t//结果为true fmt.Println(strings.Contains(s1,\u0026#34;helll\u0026#34;))\t//结果为false 获取某字符串在另一字符串中位置(索引) 返回为str在字符串s中的第一个索引位置，若str为字符串，则返回第一个字符对应的索引位置。\n1 2 3 strings.Index(s, str string) int\tstrings.LastIndex(s, str string) int\t//规则同Index，但是返回最后一个符合的索引位置 strings.IndexRune(s string, r rune) int\t//适用于非ASCII字符串 示例：\n1 2 3 4 s1 := \u0026#34;hello\u0026#34; fmt.Println(strings.Index(s1, \u0026#34;l\u0026#34;))\t//结果为2 fmt.Println(strings.Index(s1, \u0026#34;el\u0026#34;))\t//结果为1 fmt.Println(strings.LastIndex(s1, \u0026#34;l\u0026#34;))\t//结果为3 出现次数统计 strings.Count(s, str string) int\n统计str在字符串s中出现的次数，并返回。\n示例：\n1 2 3 s1 := \u0026#34;hello\u0026#34; fmt.Println(strings.Count(s1, \u0026#34;l\u0026#34;))\t//结果为2 fmt.Println(strings.Count(s1, \u0026#34;e\u0026#34;))\t//结果为1 重复字符串 重复count次字符串s，并返回。\n1 strings.Repeat(s, count int) string 示例：\n1 2 s1 := \u0026#34;hello \u0026#34; fmt.Println(strings.Repeat(s1, 3)) 从字符串中读取内容 函数 strings.NewReader() 用于生成一个 Reader 并读取字符串中的内容，然后返回指向该 Reader 的指针，从其它类型读取内容的函数还有：\nRead()从[]byte中读取内容。 ReadByte() 和 ReadRune()从字符串中读取下一个 byte 或者 rune。\n字符串替换 strings.Replace(str, old, new string, n int) string\n将字符串str中的前 n 个字符串old替换为字符串new，并返回一个新的字符串。如果n = -1则替换所有字符串old为字符串new\n示例：\n1 2 3 s1 := \u0026#34;hello\u0026#34; fmt.Println(strings.Replace(s1,\u0026#34;l\u0026#34;,\u0026#34;o\u0026#34;,1))\t//heolo fmt.Println(strings.Replace(s1,\u0026#34;l\u0026#34;,\u0026#34;o\u0026#34;,-1))\t//heooo 修剪字符串 使用 strings.TrimSpace() 来剔除字符串开头和结尾的空白符号\n如果想要剔除指定字符，则可以使用 strings.Trim(s, \u0026quot;cut\u0026quot;) 来将开头和结尾的 cut 部分去除掉\n如果只想剔除开头或者结尾的字符串，则可以使用 strings.TrimLeft 或者 strings.TrimRight 来实现\n示例：\n1 2 3 4 5 6 s1 := \u0026#34; hello \u0026#34;\ts2 := \u0026#34;hellhe\u0026#34;\tfmt.Println(strings.TrimSpace(s1))\t//hello fmt.Println(strings.Trim(s2, \u0026#34;he\u0026#34;))\t//ll fmt.Println(strings.TrimLeft(s2, \u0026#34;he\u0026#34;))\t//llhe fmt.Println(strings.TrimRight(s2, \u0026#34;he\u0026#34;))\t//hell 大小写转换 1 2 strings.ToLower(s) string\t//将字符串s中的所有大写字母转换为小写字母 strings.ToUpper(s) string\t//将字符串s中的所有小写字母转换为大写字母 示例：\n1 2 3 4 s1 := \u0026#34;hello!\u0026#34; fmt.Println(strings.ToUpper(s1)) s2 := \u0026#34;HeLLO!\u0026#34; fmt.Println(strings.ToLower(s2)) strconv包 strconv包为go提供了许多字符串与其他类型转换的函数。\n数字转换字符串 strconv.Itoa(i int) string\n返回数字 i 所表示的字符串类型的十进制数\nstrconv.FormatFloat(f float64, fmt byte, prec int, bitSize int) string\n将 64 位浮点型的数字f转换为字符串并返回，其中 fmt 表示格式（其值可以是 \u0026lsquo;b\u0026rsquo;、\u0026rsquo;e\u0026rsquo;、\u0026lsquo;f\u0026rsquo; 或 \u0026lsquo;g\u0026rsquo;），prec 表示精度，bitSize 则使用 32 表示 float32，用 64 表示 float64\n字符串转换数字 转换为整形 strconv.Atoi(s string) (i int, err error)\n将数字字符串s转化为整数i，并返回，如果产生错误，返回err\n示例：\n1 2 3 4 5 6 s1 := \u0026#34;123\u0026#34; a, err := strconv.Atoi(s1) // 若不需要返回错误，可以直接这样写： //a, _ := strconv.Atoi(s1) fmt.Println(a) fmt.Println(err) 转换为浮点型 strconv.ParseFloat(s string, bitSize int) (f float64, err error)\n将数字字符串(可以含小数)s转换为浮点型f，如果产生错误，返回err，bitSize可以位32或64，表示float32或float64\n其他 1 strconv.IntSize\t//获取程序运行的操作系统平台下 int 类型所占的位数 ","date":"2022-10-19T17:35:23Z","permalink":"http://blog.nothingalr8.top/post/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84go5-%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"从零开始的Go(5)-字符串"},{"content":"基本运算符 算数运算符 运算符 描述 + 加法运算 - 减法运算 * 乘法运算 / 除法运算 % 取余运算 ++ 自增运算 \u0026ndash; 自减运算 其中除自增运算与自减运算为一元运算符，其余为二元运算符。\n关系运算符 关系运算符都为二元运算符，用于比较两个值的大小，并返回一个布尔值。\n运算符 描述 == 等号 != 不等号 \u0026gt; 大于号 \u0026lt; 小于号 \u0026gt;= 大于等于号 \u0026lt;= 小于等于号 逻辑运算符 逻辑运算符的对象是布尔值，也可以是一个结果为布尔值的表达式。\n运算符 描述 ! 非运算 \u0026amp;\u0026amp; 与运算 || 或运算 其中非运算为一元运算符，与运算与或运算为二元运算符。\n位运算符 运算符 描述 \u0026amp; 按位与 | 按位或 ^ 按位异或、按位补足 \u0026amp;^ 按位清除 ~ 按位取反 \u0026laquo; 位左移 \u0026raquo; 位右移 其中^可用作一元运算符或二元运算符。\n其他 Go语言中也支持+=、-=等运算。\nmath包 在Go语言中，math包提供了一些基本的数学函数与常量。\n常量 1 2 3 4 5 6 7 8 9 10 11 12 13 math.E= 2.71828182845904523536028747135266249775724709369995957496696763 math.Pi = 3.14159265358979323846264338327950288419716939937510582097494459 math.Phi = 1.61803398874989484820458683436563811772030917980576286213544862 math.Sqrt2 = 1.41421356237309504880168872420969807856967187537694807317667974 math.SqrtE = 1.64872127070012814684865078781416357165377610071014801157507931 math.SqrtPi = 1.77245385090551602729816748334114518279754945612238712821380779 math.SqrtPhi = 1.27201964951406896425242246173749149171560804184009624861664038 math.Ln2 = 0.693147180559945309417232121458176568075500134360255254120680009 math.Log2E = 1 / Ln2 math.Ln10 = 2.30258509299404568401799145468436420760110148862877297603332790 math.Log10E = 1 / Ln10 函数 1 2 3 4 5 6 7 8 9 math.Abs() //绝对值 math.Ceil()\t//向上取整 math.Floor() //向下取整 math.Mod() //取余数，同11%3 math.Modf() //取整数，取小数 math.Pow() //x的y次方 math.Pow10() // 10的n次方 math.Sqrt() //开平方 math.Cbrt()) //开立方 ","date":"2022-10-18T13:35:23Z","permalink":"http://blog.nothingalr8.top/post/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84go4-%E8%BF%90%E7%AE%97/","title":"从零开始的Go(4)-运算"},{"content":"常量与变量 常量 定义 使用const关键字来定义常量，用以存储不会改变的布尔型、整数、浮点数、字符串或是复数。\n定义格式 ：const identifier [type] = value\n如：\n1 const Pi = 3.14 其中[type]部分可以省略，编译器会自动识别其类型。\n而[value]部分可以为表达式或无视精度限制(但在赋值给精度较小的变量时会错误发生或精度损失)。\n[value]部分不可以为自定义函数，但可以为内置函数，如len()。\n特殊常量值iota与枚举用法 iota是go语言中的一个特殊常量值，只能被用于常量的赋值中。\n在每一个const关键字出现时，iota就会被重置为0，然后每出现一个常量，iota所代表的数值会自动增加1。\niota可以被用作枚举值，如：\n1 2 3 4 5 const ( Female = iota Male = iota Unknown = iota ) 其运行后，Female = 0，Male = 1，Unknown = 2。与以下代码效果类似：\n1 2 3 4 5 const ( Female = 0 Male = 1 Unknown = 2 ) 而这也可以简写成下面这种形式：\n1 2 3 4 5 const ( Female = iota Male Unknown ) iota也可以被用在表达式中，如：iota + 10\n变量 定义 使用var关键字来定义常量。\n定义格式：\nvar identifier [type] var identifier [type] = [value] identifier := [value] 其中[type]部分一样可以省略，会由编译器来自动识，不过这不是所有时候都适用的。\n当一个变量被声明之后，会被自动赋予一个默认值：int为0，float为0.0，bool为false，string为空字符串，指针为nil。\n注意：若一个变量被定义后却未被使用会导致运行报错。\n只写变量_ _作为go中的一个只写变量，即只能对其赋值，而不能读取它的值，可以用它来舍弃一些不需要的值。如：\n1 _,b = 5, 7 最终5的值被抛弃了。\n数据类型 布尔型 bool，用于存储true或false。\n整数型 Go中的整数型分为int，int8，int16，int32，int64，uint，uint8，uint16，uint32，uint64，rune，byte。\n其中，int 和 uint 一般为32位，而int8，int16等的位数取决于变量类型最后的数字。\n虽然int与int32在一般状况下大小相同，但是进行数据传递时一样需要类型转换，uint与uint32同理。\n同时，Go中还有两种特殊的整数类型：\nrune ：与 int32 等价，代表了一个Unicode码点。 byte ：与 uint8 等价，代表了ASCII码的一个字符。 浮点型 Go中的整数型分为float32和float64两种，其位数与整数型命名规则相同。\nfloat32精确到小数点后7位，float64精确到小数点后15位。\n应该尽可能地使用float64，因为math 包中所有有关数学运算的函数都会要求接收这个类型。\n复数型 在Go中用complex64来表示32位实数和虚数，用complex128来表示64位实数和虚数。\n一个复数使用re+imI来表示，其中re代表实数部分，im代表虚数部分，、I` 代表根号负1，如：\n1 var c1 complex64 = 5 + 10i 函数real(c)和imag(c)可以分别获得相应的实数和虚数部分。\n字符型 严格来说，Go语言中没有字符类型，只是一种特殊的整数类型。\nbyte byte类型是uint8的别称，可以表示单个ASCII字符。\n1 2 3 var ch byte = \u0026#39;A\u0026#39;\t//直接通过字符赋值 var ch byte = 65 //通过十进制ASCII码赋值 var ch byte = \u0026#39;\\x41\u0026#39;\t//通过十六进制ASCII码赋值 rune rune类型是int32的别称，用于表示单个Unicode(UTF-8)字符。\n在书写 Unicode 字符时，需要在16进制数之前加上前缀\\u或者\\U。\\u前缀跟着4位十六进制表示2个字节的Unicode字符，而\\U前缀跟着8位十六进制表示2个字节以上的Unicode字符。\n1 2 3 var ch rune = \u0026#39;\\u0041\u0026#39;\tvar ch2 rune = \u0026#39;\\u03B2\u0026#39; var ch3 rune = \u0026#39;\\U00101234\u0026#39; 包unicode包含了一些针对测试字符的非常有用的函数，如：\n判断是否为字母：unicode.IsLetter(ch) 判断是否为数字：unicode.IsDigit(ch) 判断是否为空白符号：unicode.IsSpace(ch) 其中ch代表字符，这些函数返回一个布尔值。\n类型别名 在使用某个类型时，可以使用type关键字给它起另一个名字，用于简化名称或解决名称冲突。\n格式： type [newname] [type]\n如：\n1 2 type TZ int\t//TZ就是int的新名称 var a TZ\t//定义a变量为TZ类型，即为int类型 但实际上，类型别名得到的新类型并非和原类型完全相同，新类型不会拥有原类型所附带的方法。\n类型转换 格式：valueOfTypeB = typeB(valueOfTypeA)\n如：\n1 2 3 var a int16 var b int = 10 a = int16(b) 注意：类型转换只能在定义正确的情况下转换成功，例如从一个取值范围较小的类型转换到一个取值范围较大的类型（将 int16 转换为 int32）。当从一个取值范围较大的类型转换到取值范围较小的类型时（将 int32 转换为 int16 或将 float32 转换为 int），会发生精度丢失（截断）的情况。\n只有相同底层类型的变量之间可以进行相互转换（如将int16类型转换成int32类型），不同底层类型的变量相互转换时会引发编译错误（如将bool类型转换为int类型）。\n","date":"2022-10-16T13:35:23Z","permalink":"http://blog.nothingalr8.top/post/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84go3-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","title":"从零开始的Go(3)-基本数据类型"},{"content":"包的思想 Go命名规则 命名要求 Go语言中的包名、函数名、变量名、常量名、类型名、语句标号和包名等所有的命名，都遵循一个简单的命名规则：一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。其中，大小写字母是不同的。\n命名自然要避开关键字，以下为Go中的25个关键字：\n1 2 3 4 5 break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 此外，还有大约三十多个预定义的名字包括内建常量、内建类型和内建函数等，命名时也应当避开。\n1 2 3 4 5 内建常量: true false iota nil 内建类型: int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune string error 内建函数: make len cap new append copy close delete complex real imag panic recover 公有和私有性 在Go中，通过字母大小写来控制包内常量、变量、类型、接口、结构、函数等的可见性的，名称以大写字母开头表示能被其它包访问或调用，以非大写字母(也可以是下划线)开头表示只能在包内使用。\n如：\n1 2 var a int\t//私有，无法被外部调用 var B string\t//公开，可以被外部调用 命名规范 命名规范并不是go的强制要求，你不按照命名规范不会影响程序的运行。但是，遵循以下规范，会使程序更加有规范，可读性更强，被更多人所接受。\n文件 文件命名一律采用小写，不用驼峰式，尽量见名思义，看见文件名就可以知道这个文件下的大概内容。其中测试文件以test.go结尾，除测试文件外，命名不出现。\n包 包名用小写，使用短命名，尽量不和标准库冲突。包名统一使用单数形式。\n变量 变量命名一般采用驼峰式，当遇到特有名词（缩写或简称，如DNS）的时候，特有名词根据是否私有全部大写或小写。\n如：\n1 2 var apiClient int\t//私有，无法被外部调用 var URLString string\t//公开，可以被外部调用 常量 同变量规则，力求语义表达完整清楚，不要嫌名字长。如果模块复杂，为避免混淆，可按功能统一定义在package下的一个文件中。\n接口 单个函数的接口名以 er 为后缀\n1 type Reader interface { Read(p []byte) (n int, err error) } 两个函数的接口名综合两个函数名，如:\ntype WriteFlusher interface { Write([]byte) (int, error) Flush() error } 三个以上函数的接口名类似于结构体名，如:\n1 type Car interface { Start() Stop() Drive() } 结构体 结构体名应该是名词或名词短语，如Account,Book，避免使用Manager这样的。如果该数据结构需要序列化，如json， 则首字母大写， 包括里面的字段。\n方法 方法名应该是动词或动词短语，采用驼峰式。将功能及必要的参数体现在名字中， 不要嫌长， 如updateById，getUserInfo.如果是结构体方法，那么 Receiver 的名称应该缩写，一般使用一个或者两个字符作为 Receiver 的名称。如果 Receiver 是指针， 那么统一使用p。 如：\n1 func (f foo) method() { ... }` `func (p *foo) method() { ... } 对于Receiver命名应该统一， 要么都使用值， 要么都用指针。\n注释 每个包都应该有一个包注释，位于 package 之前。如果同一个包有多个文件，只需要在一个文件中编写即可；如果你想在每个文件中的头部加上注释，需要在版权注释和 Package前面加一个空行，否则版权注释会作为Package的注释。如：\n// Copyright 2009 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. package net\n每个以大写字母开头（即可以导出）的方法应该有注释，且以该函数名开头。如：\n1 // Get 会响应对应路由转发过来的 get 请求 func (c *Controller) Get() { ... } 大写字母开头的方法以为着是可供调用的公共方法，如果你的方法想只在本包内掉用，请以小写字母开发。如:\n1 func (c *Controller) curl() { ... } 注释应该用一个完整的句子，注释的第一个单词应该是要注释的指示符，以便查找。\n注释应该以一个句点 . 结束。\n","date":"2022-10-15T22:35:23Z","permalink":"http://blog.nothingalr8.top/post/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84go2-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E4%B8%8E%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/","title":"从零开始的Go(2)-基本结构与命名规则"},{"content":"Golang 通过访问官网进行下载。\nIDE 选择Goland或VS Code\nGoland 前往官网\nGoland是一款收费的软件，但是如果你可以在官网申请学生认证，获得免费使用权。\nVS Code 官网\n","date":"2022-10-14T13:35:23Z","permalink":"http://blog.nothingalr8.top/post/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84go1-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/","title":"从零开始的Go(1)-环境安装"},{"content":"前言 关于Go 参考教程 [Go 入门指南](《Go 入门指南》 | Go 技术论坛 (learnku.com)) [Go 语言之旅](Go 语言之旅 (go-zh.org)) [菜鸟教程](Go 语言教程 | 菜鸟教程 (runoob.com)) ","date":"2022-10-13T13:35:23Z","image":"http://blog.nothingalr8.top/Go1.jpg","permalink":"http://blog.nothingalr8.top/post/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84go0-%E5%89%8D%E8%A8%80/","title":"从零开始的Go(0)-前言"},{"content":"Markdown概述 简介 Markdown语言是一种简单的标记语言,语法简单,排版简洁,一般为.md格式的文件,而Github等众多网站都支持Markdown的语法。\n我与Markdown 而这个网站所采用的就是markdown语言,这也是我开始学习Markdown的原因,我也乘着自己学习Markdown之时来编辑博客的第一个学习项目——Markdown语言。\n参考教程 https://markdown.com.cn/ https://zhuanlan.zhihu.com/p/99319314 https://www.runoob.com/markdown/md-tutorial.html Markdown语法 标题 Markdown中,在一行的开始添加#来表示标题(#与文本之间有一个空格),#的数量表示标题的级,级越低,字体越大,从一级标题到六级标题逐渐变小。 也可采用在文本下加任意数量的 ==号来标识一级标题或--号来标识标题二级标题。\n一级标题 # 一级标题\n一级标题 1 2 一级标题 ========= 二级标题 ## 二级标题\n二级标题 1 2 二级标题 -------- 三级标题 ### 三级标题\n四级标题 #### 四级标题\n五级标题 ##### 五级标题\n六级标题 ###### 六级标题\n换行与段落 Markdown中,在一行的末尾添加两个及以上的空格然后按回车即可创建一个换行,或在一行中使用\u0026lt;br\u0026gt;来换行。空白格会对文本进行分隔,来表示段落。 注意:不要使用空格或制表符(Tab)来缩进段落。\n粗体、斜体、下划线、删除线 在文本前后各添加两个星号(**)或下划线(__)来加粗, 在文本前后各添加一个星号(*)或下划线(_)来表示斜体。 但在加粗一个单词或时一个单词变为斜体时,一般不使用下划线。 在文本前后各添加两个加号(++)来给文本加下划线。 在文本前后各添加两个波浪号(~~)来给文本加删除线。\n字体效果 Markdown语法 预览效果 斜体 *Hello* Hello 粗体 **Hello** Hello 加下划线 ++Hello++ ++Hello++ 加删除线 ~~Hello~~ Hello 引用、代码 在一行最前方用符号(\u0026gt;)来创建块引用。可以使用多个(\u0026gt;)来实现嵌套。\nHello\nhi\n你好\n1 2 3 \u0026gt;Hello \u0026gt;\u0026gt;hi \u0026gt;\u0026gt;\u0026gt;你好 使用反引号(`)(在键盘左上角,esc下方这个键)将单词括起来表示代码,但只能在一行之间显示,如果有多行代码,需要每行都使用。 #include \u0026lt;stdio\u0026gt;\n在一段代码的前后使用三个反引号(```)或三个波浪号(~~~)来表示代码块。\n1 2 3 4 5 6 #include \u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;Hello World!\u0026#34;); return 0; } 列表 有序列表 在每个列表项前添加数字加一个英文句号(如1.)来创建有序列表。数字可以不按数学顺序(会自动修正成数学顺序),但必须从1开始。用缩进来嵌套列表。 A B C 1 2 3 1. A 2. B 3. C 无序列表 在每个列表项前添加一个添加破折号 (-)、星号 (*) 或加号 (+) 来创建无序列表,注意符号与文本之间有一个空格。同样用缩进来嵌套列表。 A B C 1 2 3 * A * B * C 任务列表 在每个列表项前添加一个破折号和一对方括号,并在方括号之前添加一个空格(- [])来建立任务列表,要使复选框打勾,就在方括号之间加一个x([x])。 A B C 1 2 3 - [x] A - [ ] B - [ ] C 分隔线 在一行内单独的使用三个或多个星号 (***)、破折号 (---) 或下划线 (___) 来表示分割线。\n链接 链接语法:[超链接显示名](超链接地址 \u0026quot;超链接title\u0026quot;) 超链接显示名:超链接的文本 超链接title:鼠标放在超链接上显示的文本 如:这是一个链接:[欢迎](https://nothingalr8.top/2022/09/19/%E6%AC%A2%E8%BF%8E/ \u0026quot;欢迎\u0026quot;) 这是一个链接:欢迎\n也可以使用\u0026lt;\u0026gt;将邮箱或网址扩起来,来表示链接。但即使未将网址用\u0026lt;\u0026gt;括起来,Markdown处理器也会自动将其转换为链接。如果不希望自动链接,就是要反引号(``)将网址括起来。\n图片 插入图片Markdown语法代码:![图片alt](图片链接)\n如:![这只是一张简简单单的图片](This_is_a_simple_picture.png) hexo图片使用 参考:https://zhuanlan.zhihu.com/p/265077468 其中图片链接可以是相对路径,绝对路径或是网络路径。 网络路径就是直接引用网上的图片,直接复制图片地址,放在圆括号中。 这种方式十分的方便,但是也存在一定的问题:\n图片失效导致无法加载; 打开网页后要再请求加载图片; 原网站限制,图片会变得不可见等。 而博客是配置在网络上的,应选择使用相对路径的方式。 我们要使用文章资源文件夹,在hexo中使用文章资源文件夹需要将博客文件目录下的config.yaml文件中更改一下配置: post_asset_folder: true\n当该配置被应用后,使用hexo new命令创建新文章时,会生成相同名字的文件夹,也就是文章资源文件夹。\n由于项目会生成新的文件目录,同时会解析Markdown中的图片路径,会导致一个问题。 如在一个文件目录下,博客名为1.md,相应的存在一个1文件夹存放图片image.jpg。 在hexo中,按理说应该是使用![](image.jpg)来使用图片,但网页中却无法正常显示。\n为了解决这个问题,我们需要使用hexo-renderer-marked插件安装这个插件,使用以下命令来安装这个插件。 npm install hexo-renderer-marked\n之后需要在源文件config.yaml更改一下配置(更改第一行,在最后添加第二到四行):\n1 2 3 4 post_asset_folder: true marked: prependRoot: true postAsset: true 转义字符 要显示Markdown语法中使用到的特殊字符需要使用转义字符反斜杠(\\)。\n需要转义的字符 字符名称 \\ 反斜杠 ` 反引号 * 星号 _ 下划线 + 加号 - 减号 . 小数点 ! 感叹号 | 竖线 # 井号 () 圆括号 [] 方括号 {} 花括号 表格 要添加表格,需要使用3个及以上减号字符(---)并使用竖线(|)来分隔每列,可以在表歌任意一端扩展表格。\nSyntax Description Header Title Paragraph Text 1 2 3 4 | Syntax | Description | | --------------| ------------| | Header | Title | | Paragraph | Text | 对齐 可以在标题行(即第二行)减号的左、右侧或两侧增加冒号来使文本对齐到左侧、右侧或是居中。\nSyntax Description Test Text Header Title Here\u0026rsquo;s this Paragraph Text And more 1 2 3 4 | Syntax | Description | Test Text | | :------ | :---------: | -------: | | Header | Title | Here\u0026#39;s this | | Paragraph | Text | And more | 脚注 要创建脚注,需要使用[^x]符号,其中x可以为任意数字,但会自动转化为连续的数字,但不能含有空格。在博客的其他位置使用[^x]: 文本为脚注添加注释。 但是hexo的默认渲染器并不支持脚注功能,需要安装hexo-reference插件。 安装代码: npm install hexo-reference 并在网站目录下的_config.yml文件中添加一下代码:\n1 2 plugins: - hexo-reference 但是使用插件会有问题,需要把注释放在最后。同时,插件似乎与next主题会产生bug,导致跳转按钮错位,我就不使用了。\n1 2 这是一个脚注[^1]。 [^1]:Hello! 使用emoji表情 使用emoji表情有两种方法\n从Emojipedia或其他源上复制表情,并粘贴在Markdown文件中。❤️ 使用表情符号简码。在Markdown中以两个冒号夹着一个表情符号的名称(:表情符号的名称:)来构成表情号简码。而此网站将为你提供各种表情符号简码。但注意,有些网站可能无法识别,比如说我的。 :smile:\t:tent: :smile:\t:tent: 内嵌html标签 在Markdown中使用html语言,并不需要额外标注,可以直接使用。但在html中markdown不适用。\n","date":"2022-09-21T12:05:15Z","permalink":"http://blog.nothingalr8.top/post/markdown%E7%AC%94%E8%AE%B0/","title":"Markdown笔记"}]